apiVersion: v1
kind: Namespace
metadata:
  annotations:
    argocd.argoproj.io/hook: PreSync
    argocd.argoproj.io/sync-wave: "-7"
  labels:
    create-ca-bundle: "true"
  name: spark-app
---
apiVersion: v1
kind: Namespace
metadata:
  annotations:
    argocd.argoproj.io/hook: PreSync
    argocd.argoproj.io/sync-wave: "-7"
  labels:
    create-ca-bundle: "true"
  name: vault
---
apiVersion: v1
kind: ServiceAccount
metadata:
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded
  name: gatekeeper-smoke-test
  namespace: gatekeeper-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded
  name: gatekeeper-smoke-test
rules:
- apiGroups:
  - templates.gatekeeper.sh
  resources:
  - constrainttemplates
  verbs:
  - create
  - delete
- apiGroups:
  - constraints.gatekeeper.sh
  resources:
  - k8sallowedrepos
  verbs:
  - create
  - delete
- apiGroups:
  - ""
  resources:
  - pods
  verbs:
  - create
  - delete
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded
  name: gatekeeper-smoke-test
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: gatekeeper-smoke-test
subjects:
- kind: ServiceAccount
  name: gatekeeper-smoke-test
  namespace: gatekeeper-system
---
apiVersion: v1
data:
  kes-policy.hcl: |
    path "kv/data/minio-tenant/*" {
      capabilities = [ "create", "read" ]
    }
    path "kv/metadata/minio-tenant/*" {
      capabilities = [ "list", "delete" ]
    }
kind: ConfigMap
metadata:
  annotations:
    argocd.argoproj.io/hook: PreSync
    argocd.argoproj.io/sync-wave: "-7"
  name: kes-policy
  namespace: vault
---
apiVersion: v1
data: {}
kind: Secret
metadata:
  annotations:
    argocd.argoproj.io/hook: Sync
    argocd.argoproj.io/sync-wave: "-8"
    replicator.v1.mittwald.de/replicate-from: minio-tenant/minio-kes-secret
  name: minio-kes-secret
  namespace: vault
---
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  annotations:
    argocd.argoproj.io/hook: Sync
    argocd.argoproj.io/sync-wave: "-20"
  finalizers:
  - resources-finalizer.argocd.argoproj.io
  name: cert-manager
  namespace: argocd
spec:
  destination:
    namespace: cert-manager
    server: https://kubernetes.default.svc
  project: default
  source:
    chart: cert-manager
    helm:
      parameters:
      - forceString: true
        name: installCRDs
        value: "true"
      values: |-
        cert-manager:
          installCRDs: true
    repoURL: https://charts.jetstack.io
    targetRevision: v1.14.5
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
    - CreateNamespace=true
    - ServerSideApply=true
---
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  annotations:
    argocd.argoproj.io/hook: Sync
    argocd.argoproj.io/sync-wave: "-6"
  finalizers:
  - resources-finalizer.argocd.argoproj.io
  name: data-sanitization
  namespace: argocd
spec:
  destination:
    namespace: spark-app
    server: https://kubernetes.default.svc
  project: default
  sources:
  - chart: data-sanitization
    helm:
      valuesObject:
        ingress:
          className: nginx
          enabled: true
          hosts:
          - host: data-sanitization.integration
            paths:
            - path: /
              pathType: Prefix
        resources:
          limits:
            cpu: 500m
            memory: 1024Mi
          requests:
            cpu: 250m
            memory: 512Mi
        s3:
          accessKeyId: minio
          certificate: /etc/ssl/certs/ca.crt
          endpoint: minio.minio-tenant.svc.cluster.local
          secretAccessKey: minio123
        secret:
          create: true
          name: minio-credentials
        volumeMounts:
        - mountPath: /etc/ssl/certs/ca.crt
          name: ca-bundle
          readOnly: true
          subPath: ca.crt
        volumes:
        - configMap:
            defaultMode: 422
            name: ca-bundle
          name: ca-bundle
    repoURL: https://glaciation-heu.github.io/data-sanitization-service
    targetRevision: 0.2.2
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
    - ServerSideApply=true
---
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  annotations:
    argocd.argoproj.io/hook: Sync
    argocd.argoproj.io/sync-wave: "-30"
  finalizers:
  - resources-finalizer.argocd.argoproj.io
  name: gatekeeper
  namespace: argocd
spec:
  destination:
    namespace: gatekeeper-system
    server: https://kubernetes.default.svc
  project: default
  source:
    chart: gatekeeper
    helm:
      values: |
        postInstall:
          labelNamespace:
            extraRules:
            - apiGroups:
              - management.cattle.io
              resources:
              - projects
              verbs:
              - updatepsa
      valuesObject:
        audit:
          resources:
            limits:
              cpu: 500m
        controllerManager:
          resources:
            limits:
              cpu: 500m
    repoURL: https://open-policy-agent.github.io/gatekeeper/charts
    targetRevision: 3.15.1
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
    - CreateNamespace=true
    - ServerSideApply=true
---
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  annotations:
    argocd.argoproj.io/hook: Sync
    argocd.argoproj.io/sync-wave: "-8"
  finalizers:
  - resources-finalizer.argocd.argoproj.io
  name: gatekeeper-policy-manager
  namespace: argocd
spec:
  destination:
    namespace: gatekeeper-system
    server: https://kubernetes.default.svc
  project: default
  source:
    chart: gatekeeper-policy-manager
    helm:
      valuesObject:
        config:
          secretKey: supersecuresecretkey
        ingress:
          enabled: true
          hosts:
          - host: gpm.integration
            pathType: Prefix
            paths:
            - /
          ingressClassName: nginx
    repoURL: https://sighupio.github.io/gatekeeper-policy-manager
    targetRevision: 0.10.0
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
    - CreateNamespace=true
    - ServerSideApply=true
---
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  annotations:
    argocd.argoproj.io/hook: Sync
    argocd.argoproj.io/sync-wave: "-8"
  finalizers:
  - resources-finalizer.argocd.argoproj.io
  name: replicator
  namespace: argocd
spec:
  destination:
    namespace: replicator
    server: https://kubernetes.default.svc
  project: default
  source:
    chart: kubernetes-replicator
    repoURL: https://helm.mittwald.de
    targetRevision: 2.9.2
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
    - CreateNamespace=true
    - ServerSideApply=true
---
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  annotations:
    argocd.argoproj.io/hook: Sync
    argocd.argoproj.io/sync-wave: "-6"
  finalizers:
  - resources-finalizer.argocd.argoproj.io
  name: spark-history-server
  namespace: argocd
spec:
  destination:
    namespace: spark-app
    server: https://kubernetes.default.svc
  project: default
  sources:
  - chart: spark-history-server
    helm:
      valuesObject:
        ingress:
          className: nginx
          enabled: true
          hosts:
          - host: spark-history-server.integration
            paths:
            - path: /
              pathType: Prefix
        resources:
          limits:
            cpu: 500m
            memory: 1024Mi
          requests:
            cpu: 250m
            memory: 512Mi
        s3:
          bucket: sanitization/spark-events
          endpoint: minio.minio-tenant.svc.cluster.local
        secret:
          create: false
          name: minio-credentials
        volumeMounts:
        - mountPath: /etc/ssl/certs/ca.crt
          name: ca
          readOnly: true
          subPath: ca.crt
        - mountPath: /opt/java/openjdk/lib/security/cacerts
          name: ca
          readOnly: true
          subPath: ca.jks
        volumes:
        - configMap:
            defaultMode: 422
            name: ca-bundle
          name: ca
    repoURL: https://glaciation-heu.github.io/spark-history-server
    targetRevision: 1.0.3
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
    - ServerSideApply=true
---
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  annotations:
    argocd.argoproj.io/hook: Sync
    argocd.argoproj.io/sync-wave: "-6"
  finalizers:
  - resources-finalizer.argocd.argoproj.io
  name: spark-operator
  namespace: argocd
spec:
  destination:
    namespace: spark-operator
    server: https://kubernetes.default.svc
  project: default
  source:
    chart: spark-operator
    helm:
      valuesObject:
        sparkJobNamespaces:
        - spark-app
        webhook:
          enable: true
    repoURL: https://kubeflow.github.io/spark-operator/
    targetRevision: 1.2.14
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
    - CreateNamespace=true
    - ServerSideApply=true
---
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  annotations:
    argocd.argoproj.io/hook: Sync
    argocd.argoproj.io/sync-wave: "-8"
  finalizers:
  - resources-finalizer.argocd.argoproj.io
  name: trust-manager
  namespace: argocd
spec:
  destination:
    namespace: cert-manager
    server: https://kubernetes.default.svc
  project: default
  source:
    chart: trust-manager
    helm:
      valuesObject:
        podDisruptionBudget:
          enabled: true
        replicaCount: 2
        secretTargets:
          authorizedSecrets:
          - ca-bundle
          enabled: true
    repoURL: https://charts.jetstack.io
    targetRevision: v0.9.2
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
    - ServerSideApply=true
---
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  annotations:
    argocd.argoproj.io/compare-options: ServerSideDiff=true
    argocd.argoproj.io/hook: Sync
    argocd.argoproj.io/sync-wave: "-8"
  finalizers:
  - resources-finalizer.argocd.argoproj.io
  name: vault
  namespace: argocd
spec:
  destination:
    namespace: vault
    server: https://kubernetes.default.svc
  project: default
  sources:
  - chart: vault
    helm:
      valuesObject:
        global:
          enabled: true
          tlsDisable: false
        injector:
          enabled: false
        server:
          affinity: ""
          auditStorage:
            enabled: true
            size: 10Gi
            storageClass: local-path
          dataStorage:
            enabled: true
            size: 10Gi
            storageClass: local-path
          enabled: true
          extraEnvironmentVars:
            VAULT_CACERT: /vault/userconfig/vault-tls/ca.crt
            VAULT_TLSCERT: /vault/userconfig/vault-tls/tls.crt
            VAULT_TLSKEY: /vault/userconfig/vault-tls/tls.key
          ha:
            enabled: true
            raft:
              config: |
                disable_mlock = true
                ui = true

                listener "tcp" {
                  address = "[::]:8200"
                  cluster_address = "[::]:8201"
                  tls_cert_file = "/vault/userconfig/vault-tls/tls.crt"
                  tls_key_file  = "/vault/userconfig/vault-tls/tls.key"
                  tls_client_ca_file = "/vault/userconfig/vault-tls/ca.crt"
                }

                storage "raft" {
                  path = "/vault/data"
                }

                service_registration "kubernetes" {}
              enabled: true
              setNodeId: true
            replicas: 3
          ingress:
            activeService: false
            annotations:
              nginx.ingress.kubernetes.io/backend-protocol: HTTPS
            enabled: true
            hosts:
            - host: vault.integration
            ingressClassName: nginx
          resources:
            limits:
              cpu: 250m
              memory: 256Mi
            requests:
              cpu: 250m
              memory: 256Mi
          service:
            active:
              enabled: false
            enabled: true
            standby:
              enabled: false
          standalone:
            enabled: false
          ui:
            enabled: true
          volumeMounts:
          - mountPath: /vault/userconfig/vault-tls
            name: userconfig-vault-tls
            readOnly: true
          volumes:
          - name: userconfig-vault-tls
            secret:
              defaultMode: 420
              secretName: vault-tls
    repoURL: https://helm.releases.hashicorp.com
    targetRevision: 0.28.0
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
    - ServerSideApply=true
---
apiVersion: batch/v1
kind: Job
metadata:
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded
  name: gatekeeper-smoke-test
  namespace: gatekeeper-system
spec:
  backoffLimit: 5
  template:
    spec:
      containers:
      - command:
        - /bin/sh
        - -c
        - |
          # Check status of the Gatekeeper service
          (
            set -e; # make sure the job fails if any instruction fails

            # Some of the following commands are meant to fail to prove the
            # successful enforcement of the policy. With the suffix '&& exit 1'
            # we force to exit with an error status whenever these commands are
            # executed successfully.
            # NOTE: This is not the same as the ! operator.

            kubectl create -f https://raw.githubusercontent.com/unibg-seclab/glaciation-gitops-test/main/resources/template.yaml;
            kubectl create -f https://raw.githubusercontent.com/unibg-seclab/glaciation-gitops-test/main/resources/constraint.yaml;
            kubectl create -f https://raw.githubusercontent.com/unibg-seclab/glaciation-gitops-test/main/resources/example_allowed.yaml -n default;
            kubectl create -f https://raw.githubusercontent.com/unibg-seclab/glaciation-gitops-test/main/resources/example_disallowed_container.yaml -n default && exit 1;
            kubectl create -f https://raw.githubusercontent.com/unibg-seclab/glaciation-gitops-test/main/resources/example_disallowed_initcontainer.yaml -n default && exit 1;
            kubectl create -f https://raw.githubusercontent.com/unibg-seclab/glaciation-gitops-test/main/resources/example_disallowed_both.yaml -n default && exit 1;

            # Overwrite last command exit status with success. Indeed, if we
            # get here the test has succeeded
            exit 0
          )

          # Store exit status of the subshell (i.e., state of the test)
          exit_code=$?

          # Restore cluster in a clean state (these always run even in case of errors above)
          kubectl delete -f https://raw.githubusercontent.com/unibg-seclab/glaciation-gitops-test/main/resources/example_allowed.yaml -n default;
          kubectl delete -f https://raw.githubusercontent.com/unibg-seclab/glaciation-gitops-test/main/resources/example_disallowed_container.yaml -n default;
          kubectl delete -f https://raw.githubusercontent.com/unibg-seclab/glaciation-gitops-test/main/resources/example_disallowed_initcontainer.yaml -n default;
          kubectl delete -f https://raw.githubusercontent.com/unibg-seclab/glaciation-gitops-test/main/resources/example_disallowed_both.yaml -n default;
          kubectl delete -f https://raw.githubusercontent.com/unibg-seclab/glaciation-gitops-test/main/resources/constraint.yaml;
          kubectl delete -f https://raw.githubusercontent.com/unibg-seclab/glaciation-gitops-test/main/resources/template.yaml

          # Return the state of smoke test
          exit $exit_code
        image: bitnami/kubectl:1.30
        name: kubectl
        resources:
          limits:
            cpu: 250m
            memory: 512Mi
          requests:
            cpu: 100m
            memory: 256Mi
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
          privileged: false
      restartPolicy: Never
      securityContext:
        runAsNonRoot: true
        seccompProfile:
          type: RuntimeDefault
      serviceAccountName: gatekeeper-smoke-test
---
apiVersion: batch/v1
kind: Job
metadata:
  annotations:
    argocd.argoproj.io/hook: Sync
    argocd.argoproj.io/sync-wave: "-8"
  name: init-vault-cluster
  namespace: vault
spec:
  backoffLimit: 50
  template:
    spec:
      containers:
      - command:
        - /bin/sh
        - -c
        - |
          set -e # make sure the job fails if any instruction fails

          function unseal {
              head -n $THRESHOLD /vault/cluster-keys |
              while read line; do
                vault operator unseal \
                  -address=https://$1.vault-internal:8200 \
                  $line;
              done
          }

          echo '[*] Initialize HA Vault cluster'
          # Wait for the startup of the Vault pods
          sleep 30 # it does the job without requiring to create an ad hoc image
          # TODO: Persist PGP encrypted Vault unseal keys somewhere outside the cluster
          vault operator init \
            -address=https://vault-0.vault-internal:8200 \
            -key-shares=$SHARES \
            -key-threshold=$THRESHOLD \
            -format=json > /vault/response.json
          # Extract unseal keys from the JSON response
          awk '/"unseal_keys_b64": \[/{flag=1;next}/\]/{flag=0}flag' /vault/response.json | sed -n 's/\s*"\(.*\)".*/\1/p' > /vault/cluster-keys
          unseal vault-0
          vault operator raft join \
            -address=https://vault-1.vault-internal:8200 \
            -leader-ca-cert="$(cat /vault/userconfig/vault-tls/ca.crt)" \
            -leader-client-cert="$(cat /vault/userconfig/vault-tls/tls.crt)" \
            -leader-client-key="$(cat /vault/userconfig/vault-tls/tls.key)" \
            https://vault-0.vault-internal:8200
          unseal vault-1
          vault operator raft join \
            -address=https://vault-2.vault-internal:8200 \
            -leader-ca-cert="$(cat /vault/userconfig/vault-tls/ca.crt)" \
            -leader-client-cert="$(cat /vault/userconfig/vault-tls/tls.crt)" \
            -leader-client-key="$(cat /vault/userconfig/vault-tls/tls.key)" \
            https://vault-0.vault-internal:8200
          unseal vault-2
          echo -e '\n[*] Setup HA Vault cluster for integration with MinIO'
          VAULT_ROOT_TOKEN=$(sed -n 's/\s*"root_token": "\(.*\)".*/\1/p' /vault/response.json)
          vault login \
            -address=https://vault-0.vault-internal:8200 \
            $VAULT_ROOT_TOKEN
          vault secrets enable \
            -address=https://vault-0.vault-internal:8200 \
            -version=2 \
            kv
          vault policy write \
            -address=https://vault-0.vault-internal:8200 \
            kes-policy /minio/kes/kes-policy.hcl
          vault auth enable \
            -address=https://vault-0.vault-internal:8200 \
            kubernetes
          vault write \
            -address=https://vault-0.vault-internal:8200 \
            auth/kubernetes/config \
            token_reviewer_jwt="$(cat /minio/kes/service-account/token)" \
            kubernetes_host="https://kubernetes.default.svc.cluster.local" \
            kubernetes_ca_cert="$(cat /minio/kes/service-account/ca.crt)" \
            issuer="https://kubernetes.default.svc.cluster.local"
          vault write \
            -address=https://vault-0.vault-internal:8200 \
            auth/kubernetes/role/minio-kes \
            bound_service_account_names=minio-kes \
            bound_service_account_namespaces=minio-tenant \
            policies=kes-policy \
            ttl=1h
        env:
        - name: SHARES
          value: "5"
        - name: THRESHOLD
          value: "3"
        image: hashicorp/vault:1.16.1
        name: vault
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
          privileged: false
          runAsGroup: 1000
          runAsUser: 100
        volumeMounts:
        - mountPath: /etc/ssl/certs/ca.crt
          name: ca-bundle
          readOnly: true
          subPath: ca.crt
        - mountPath: /vault/userconfig/vault-tls
          name: userconfig-vault-tls
          readOnly: true
        - mountPath: /minio/kes/service-account
          name: minio-kes-service-account-token
          readOnly: true
        - mountPath: /minio/kes/kes-policy.hcl
          name: kes-policy
          readOnly: true
          subPath: kes-policy.hcl
      restartPolicy: Never
      securityContext:
        runAsGroup: 1000
        runAsNonRoot: true
        runAsUser: 100
        seccompProfile:
          type: RuntimeDefault
      volumes:
      - configMap:
          defaultMode: 422
          name: ca-bundle
        name: ca-bundle
      - name: userconfig-vault-tls
        secret:
          defaultMode: 420
          secretName: vault-tls
      - name: minio-kes-service-account-token
        secret:
          defaultMode: 420
          secretName: minio-kes-secret
      - configMap:
          defaultMode: 420
          name: kes-policy
        name: kes-policy
---
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  annotations:
    argocd.argoproj.io/sync-options: SkipDryRunOnMissingResource=true
    argocd.argoproj.io/sync-wave: "-8"
  name: my-selfsigned-ca
  namespace: cert-manager
spec:
  commonName: my-selfsigned-ca
  isCA: true
  issuerRef:
    group: cert-manager.io
    kind: ClusterIssuer
    name: selfsigned-issuer
  privateKey:
    algorithm: ECDSA
    size: 256
  secretName: root-secret
---
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  annotations:
    argocd.argoproj.io/hook: Sync
    argocd.argoproj.io/sync-options: SkipDryRunOnMissingResource=true
    argocd.argoproj.io/sync-wave: "-8"
  name: vault-certificate
  namespace: vault
spec:
  commonName: system:node:*.vault.svc.cluster.local
  dnsNames:
  - '*.vault-internal'
  - '*.vault-internal.vault.svc.cluster.local'
  - '*.vault'
  - vault-internal.vault.svc.cluster.local
  duration: 2160h
  ipAddresses:
  - 127.0.0.1
  - 192.168.49.2
  isCA: false
  issuerRef:
    group: cert-manager.io
    kind: ClusterIssuer
    name: private-ca-issuer
  privateKey:
    algorithm: RSA
    size: 2048
  renewBefore: 360h
  secretName: vault-tls
  subject:
    organizations:
    - system:nodes
  usages:
  - digital signature
  - key encipherment
  - data encipherment
  - server auth
  - client auth
---
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  annotations:
    argocd.argoproj.io/sync-options: SkipDryRunOnMissingResource=true
    argocd.argoproj.io/sync-wave: "-8"
  name: private-ca-issuer
spec:
  ca:
    secretName: root-secret
---
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  annotations:
    argocd.argoproj.io/sync-options: SkipDryRunOnMissingResource=true
    argocd.argoproj.io/sync-wave: "-8"
  name: selfsigned-issuer
spec:
  selfSigned: {}
---
apiVersion: trust.cert-manager.io/v1alpha1
kind: Bundle
metadata:
  annotations:
    argocd.argoproj.io/hook: Sync
    argocd.argoproj.io/sync-options: SkipDryRunOnMissingResource=true
    argocd.argoproj.io/sync-wave: "-8"
  name: ca-bundle
spec:
  sources:
  - useDefaultCAs: true
  - configMap:
      key: ca.crt
      name: kube-root-ca.crt
  - secret:
      key: ca.crt
      name: root-secret
  target:
    additionalFormats:
      jks:
        key: ca.jks
    configMap:
      key: ca.crt
    namespaceSelector:
      matchLabels:
        create-ca-bundle: "true"
    secret:
      key: ca.crt
